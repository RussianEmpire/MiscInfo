Задача:

Опишите и исправьте проблемы (если они есть) в этом классе и приведите код для конструктора копирования и оператора присваивания.
Приведите собственную реализацию, как вы бы сделали в промышленном коде.

class SomeClass {
public:
  SomeClass() {
    ptr1 = new char[4096];
    ptr2 = new char[256 * 1024];
  }
private:
  char* ptr1, *ptr2;
};


Решение:

Проблем в этом классе множество. Опишем и исправим их все.

1) Небезопасная инициализация класса

Конструктор класса НЕ обеспечивает даже базовый (level 3, basic) уровень безопасности (https://en.wikipedia.org/wiki/Exception_safety)

Код был исправлен таким образом, чтоы обеспечивать strong exception safety (also known as commit or rollback semantics):
 экземпляр класса будет корректно инициализирован полностью (и перейдёт таким образом в новое состояние)
  или, в случае ошибки, останется в валидном, но неинициализорванном состоянии и никакие ресурсы при этом не "утекут".
Для поверки (извне) корректности последней операции (включая инициализацию) с объектом класса были введены две публичные функции - индикаторы.
Если ввиду нехватки памяти объект не удалось корректно инициализировать изначально, можно освободить память и попытаться создать объект снова.

2) Некорретная деинициализация класса

Деструктор в классе изначально отстутствовал, хотя класс не являлся аггрегатным POD-типом.
Так же отсутсвуют какие-либо способны ручного управления памятью (методы класса типа 'free' / 'drop' / 'clear' или как угодно).
Это ГАРАНТИРУЕТ утечку памяти даже в случае полностью корректной инициализации класса, так как извне нет доступа к указателям
 (за исключением тех случаев, когда исползуются небезопасные грязные хаки со смещением адресов для доступа к приватным полям)
  таким образом внешний код никогда не узнает адресов выделенных блоклов памяти и, соответсвенно, не сможет их корретно удалить (вернуть аллокатору).

Отсутствие явно определённого дестуктора при явно определённых конструкторе копирования и операторе присваивания так же нарушает правило трёх (правило пяти для C++11).

Конструктор и оператор переноса были мною явным бразом удалены, так как в задаче не сказано, чтобы класс поддерживал семантику перемещения (передачу управления ресурсами),
 но при этом Google C++ Style Guide требует явно определять все стандартные методы класса (конструкторы, операторы, деструктор, согласно правилу трёх или пяти),
  в том числе возлагая их реализацию на компилятор (default) или запрещая их генерацию и использование (delete).

Для предотвращения утечки памяти я использовал идиому RAII, обеспечивая автоматическое управления динамической памятью.

3) Плохой стиль

В коде изначально присутствовало довольно ущербное форматирование, а так же магические константы.
Кроме того, в современном C++ коде следует избегать ручного управления динамической памятью, предпочитая вместо этого использовать (в порядке убывания приоритета):
  std::array -> std::vector -> RAII

Итоговый код: (стандарт C++11)


class SomeClass {
  static constsexpr const auto MEM1_SIZE_ = 4096UL;
  static constsexpr const auto MEM2_SIZE_ = 256U * 1024U;
public:
  SomeClass() noexcept {
    init();
  }
  
  ~SomeClass() = default;
  
  SomeClass& operator=(const SomeClass& other) noexcept {
    if (!inited()) { // lazy fail-safe initialization
      if (!init()) return *this;
    }
    memcpy(ptr1, other.ptr1, MEM1_SIZE_);
    memcpy(ptr2, other.ptr2, MEM2_SIZE_);
    
    lastOpOk = true;
    return *this;
  }
  
  SomeClass(const SomeClass& other) noexcept {
    *this = other;
  }
  
  constexpr bool inited() const noexcept {
    return ptr1.get() && ptr2.get(); // in fact, only one need to be checked
  }
  
  bool init() noexcept {
    if(inited()) return true;
    
    std::unique_ptr<char[]> ptr1new = new(std::nothrow) char[MEM1_SIZE_](); // zero init.
    std::unique_ptr<char[]> ptr2new = new(std::nothrow) char[MEM2_SIZE_]();
    if (!ptr1new.get() || !ptr2new.get())
      return lastOpOk = false;
    
    ptr1 = ptr1new, ptr2 = ptr2new; // transfers  ownership
    return true;
  }
  
  constexpr bool isLastOpOk() const noexcept {
    return lastOpOk;
  }
private:
  SomeClass(const SomeClass&) = delete;
  SomeClass& operator=(SomeClass&&) = delete;
  
  bool lastOpOk = true; // last operation correctness flag (initial state - normal)
  std::unique_ptr<char[]> ptr1(nullptr), ptr2(nullptr);
};
