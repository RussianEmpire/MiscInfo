Задача:

Есть некоторый объект (например, контейнер STL), который в конкурентной среде (несколькими потоками) изменяется и читается.
Соотношение операций чтение / запись: 95/5 (на одну операцию записи приходится 19 операций чтения).
Приведите несколько способов организации доступа к данным объекта, опишите плюсы и минусы каждого способа.
______________________________________________________________________________________________________________________________________

Решение:

Задача сформулирована слишком широко, что порождает множество возможных вариантов её решения.
Рассмотрим примеры решений в случае с некоторым абстрактным контейнером.

--------------------------------------------------------------------------------------------------------------------------------------

Стратегия А: синхронизация контейнера целиком

--------------------------------------------------------------------------------------------------------------------------------------

0) Взять изначально готовую потокобезопасную (ИЗНУТРИ) реализацию контейнера

Плюсы:

- решение из коробки: не нужно писать никакого дополнительного кода (быстро, просто)

Минусы:

- её надо где-то взять, т. е. придётся связываться с какой-то третьесторонней библиотекой, нет гарантий, что там нет ошибок
  (если ошибки будут найдены, не ясно что с ними делать: исправлять самому и делать пулл реквест или искать другую реализацию)

- (скорее всего) не гибкое, не масштабируемое решение: разработчик контейнера не может заранее знать,
   в каких условиях будет использоваться контейнер,
    т. е. код скорее всего будет жёстко синхронизирован в лоб, без простора для оптимизаций
     (избежания лишних блокировок там, где они ситуационно не нужны)

- (скорее всего) низкопроизводительная [не совсем: http://preshing.com/20111118/locks-arent-slow-lock-contention-is]
   блокирующая синхронизация

- (скорее всего) отсутствие необходимости выделять много дополнительной памяти

- хотя сам по себе контейнер синхронизирован, не очень понятно, как при этом обстоит дело с синхронизацией ХРАНИМЫХ контейнером объектов
   (контейнер возвращает нам их копии при обращении или объекты уже каким-то образом синхронизированы?)

--------------------------------------------------------------------------------------------------------------------------------------

1) Синхронизация доступа ко всему контейнера ИЗВНЕ контейнера

Сам контейнер реализован НЕ потокобезопасно, а синхронизацию ВСЕХ операций чтения и записи берёт на себя непосредственно тот код,
 который и осуществляет чтение/запись (либо контейнер оборачивается в примитивную синхронизированную обёртку, что сложнее).
За контейнером закрепляется ОДНА единственная критическая секция, которая блокирует ЛЮБОЙ параллельный доступ к контейнеру.
Т. е. доступ к контейнеру ВСЕГДА эксклюзивный: один поток пишет или читает, остальные ждут.

Плюсы:

- простота реализации: всего один примитив синхронизации, минимум точек синхронизации и, как следствие,
   минимум потенциальных, сложно локализуемых, сложно воспроизводимых ошибок синхронизации

- отсутствие необходимости выделять много дополнительной памяти

- хороший вариант для обратного случая: много записей, мало чтения
  (имеется ввиду когда изменять нужно САМ контейнер, причём эксклюзивно, а не по частям - например, вектор)

Минусы:

- ОЧЕНЬ плохая масштабируемость в системе с большим количеством потоков в своей абсолютной массе работающих на чтение
  (т. е. решение ТОЧНО не для указанного случая, как максимум временно-костыльный вариант
   или вариант для нетребовательных ко времени отклика систем)

- низкопроизводительная (блокировка по цене примерно как переключение контекста) блокирующая синхронизация
  (к слову, в WinAPI критическая секция оптимизирована для случаев отсутствия РЕАЛЬНОЙ конкуренции - выход из критической секции дешевле,
   если за время блокировки конкурентные потоки в неё НЕ входили)

- не лучший вариант для контейнеров с распределённой структурой хранения (хэш-карты, дэки),
   которые позволяют выстраивать более гибкие и масштабируемые стратегии синхронизации, единовременно блокирующие
    лишь часть контейнера, а не весь

--------------------------------------------------------------------------------------------------------------------------------------

2) Копирование контейнера при чтении

Способ синхронизации во многом аналогичен п. 1, НО
КАЖДЫЙ читающий поток эксклюзивно блокирует контейнер ТОЛЬКО на время создания его ПОЛНОЙ копии.
Далее поток работает уже со своей индивидуальной копией.

Плюсы:

- простота реализации: всего один примитив синхронизации, минимум точек синхронизации и т. д.

- (в определённых случаях) эффективность по времени:
   работающий со своей индивидуальной копией поток НИКАК не мешает массе других потоков
   (в нашем случае, в первую очередь, читающих)

- удобно в том случае, когда много читающих потоков достаточно БЫСТРО делают копии
   и потом долго с этими своими индивидуальными копиями работают,
    таким образом, редко обращаясь за релевантным состоянием исходного объекта и не препятствуя его свободному изменению в это время

Минусы:

- медленная блокирующая синхронизация

- не применимо, если читающие потоки ВСЕГДА должны видеть актуальное состояние контейнера
  (оно может изменится за время работы с копией, которая, таким образом, утрачивает релевантность)

- не имеет смысла в тех случаях, когда статистически среднее время чтения контейнера потоком меньше или сопоставимо
   со средним временем копирования этого контейнера (пустая трата времени и памяти на копирование, лишняя фрагментация памяти)

- требует дополнительной памяти, особенно критично:
   а) для систем с сильно ограниченным общим объёмом памяти
   б) в случае большого размера контейнера и/или большого количества потоков чтения
   в) для кода собранного с низкой разрядностью указателя, не способного адресовать большие объёмы виртуальной памяти
      (пример: ОС Win32, приложение с 32-ух битными указатели, не поддерживающими большие адреса [LargeAddressAware],
       в системе с установленным дефолтным ограничением 2 Гб/процесс)

- постоянное выделение/освобождение памяти порождает фрагментацию
  (можно попытаться избавиться от этого, выделяя память заранее и затем используя только её)

--------------------------------------------------------------------------------------------------------------------------------------

3) Копирование контейнера при записи

В системе изначально ОДНОВРЕМЕННО хранится ДВА одинаковых экземпляра контейнера:
 1) свободно (блокировка и синхронизация ТОЛЬКО на время регистрации доступа к контейнеру)
     читаемый ЛЮБЫМ количеством ТОЛЬКО читающих потоков
 2) недоступный для потоков чтения и ожидающий операцию записи

Когда читающему потоку необходимо получить доступ к контейнеру, он обращается к специальной глобальной структуре,
 примерный макет реализации такой структуры (с тестом, C++11):

#include <mutex>
#include <atomic>
#include <cstddef>
#include <cassert>

template<class TObjType>
class RefCountAutoDeleter {
public:

  // Throws std::bad_alloc on error
  explicit RefCountAutoDeleter(const TObjType* const objToCopy = nullptr) {
    if (objToCopy) {
      controlledObjPtr = new TObjType(*objToCopy); // copy constr.
    } else {
      controlledObjPtr = new TObjType; // default constr.
    }
  }
  
  // If 'deleteOnDrop' flag is true - the controlled object MUST be first allocated using 'new'
  explicit RefCountAutoDeleter(TObjType& objToControl, const bool deleteObjOnDrop = true)
    : controlledObjPtr(&objToControl), dynamicObj(deleteObjOnDrop) {}
  
  // Automatically finalizes
  ~RefCountAutoDeleter() noexcept {
    finalize();
    while (refCount.load(std::memory_order_acquire)) // wait while NOT released ALL
    std::this_thread::sleep_for(std::chrono::milliseconds(10U)); // 1/100 sec.
  }
  
  // Returns nullptr if finalized
  // (a new version of the controlled object must then be reacquired from the new controller)
  TObjType* get() noexcept {
    if (dropFlag.load(std::memory_order_acquire)) return nullptr;
    const std::lock_guard<decltype(synchronizer)> autoLock(synchronizer);
    if (dropFlag.load(std::memory_order_relaxed)) return nullptr; // double checking lock
    
    ++refCount; // memory_order_acq_rel
    return controlledObjPtr;
  }
  
  // Returns false on ANY error
  bool release() noexcept {
    const std::lock_guard<decltype(synchronizer)> autoLock(synchronizer);
    
    assert(refCount.load(std::memory_order_relaxed));
    if (!refCount.load(std::memory_order_relaxed))
    return false; // ref. counter was used incorrectly
    --refCount; // memory_order_acq_rel
    
    if (dropFlag.load(std::memory_order_relaxed)) // if marked for drop
    tryDrop(); // will drop if NO more references
    return true;
  }
  
  void finalize() noexcept {
    const std::lock_guard<decltype(synchronizer)> autoLock(synchronizer);
    dropFlag.store(true, std::memory_order_release); // mark for drop
    tryDrop(); // will drop if NO more refs
  }
  
  size_t getRefCount() const noexcept {
    return refCount.load(std::memory_order_acquire);
  }
  
  bool isFinalized() const noexcept {
    return dropFlag.load(std::memory_order_acquire);
  }
private:
  RefCountAutoDeleter(const RefCountAutoDeleter&) noexcept = delete;
  RefCountAutoDeleter(RefCountAutoDeleter&&) noexcept = delete;
  
  RefCountAutoDeleter& operator=(const RefCountAutoDeleter&) noexcept = delete;
  RefCountAutoDeleter& operator=(RefCountAutoDeleter&&) noexcept = delete;
  
  void tryDrop() noexcept {
    // SHOULD use relaxed load under lock
    // [http://stackoverflow.com/questions/6086912/double-checked-lock-singleton-in-c11]
    if (refCount.load(std::memory_order_relaxed)) return; // too early
    
    if (dynamicObj) delete controlledObjPtr;
    controlledObjPtr = nullptr;
  }
  
  bool dynamicObj = true;
  TObjType* controlledObjPtr = nullptr;
  
  std::atomic<size_t> refCount = size_t();
  std::atomic<bool> dropFlag = false; // can NOT became false once become true
  std::mutex synchronizer;
};

////

#include <string>
#include <thread>
#include <random>
#include <vector>
#include <iostream>

struct TestObj {
  TestObj() {
    std::cout << "Creating test object\n";
  }
  
  ~TestObj() {
    std::cout << "Destroying test object\n";
  }
};

void f1(std::string* const str, RefCountAutoDeleter<TestObj>* const counter) noexcept {
  static std::mutex SYNCH_;
  
  assert(str && counter);
  auto const testObjRef = counter->get();
  assert(testObjRef && counter->getRefCount());
  
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_int_distribution<size_t> dis(700U, 900U);
  
  const auto limit = dis(gen);
  for (auto i = size_t(); i < limit; ++i) {
    { // exclusive lock for the str.
      const std::lock_guard<decltype(SYNCH_)> autoLock(SYNCH_);
      // 66%: add [a - z]; 33% - drop last
      i % 3U ? (*str += 'a' + (i % 26U)) : str->erase((str->length() ? (str->length() - 1U) : 0U), 1U);
    }
    std::this_thread::sleep_for(std::chrono::nanoseconds(100U)); // NO need to wait really
  }
  counter->release();
}

int main(int argc, char* argv[]) {
  auto s1ptr = new(std::nothrow) std::string;
  auto const testObjPtr = new(std::nothrow) TestObj;
  assert(s1ptr && testObjPtr);
  RefCountAutoDeleter<TestObj> testObjCounter(*testObjPtr, true); 
  
  std::vector<std::thread> threads;
  for (auto i = size_t(); i < 8U; ++i)
    threads.emplace_back(f1, s1ptr, &testObjCounter);
  
  for (auto& currThread : threads) {
    try {
      currThread.join();
    } catch (const std::system_error& err) {
      std::cout << "[" << err.code() << "] " << err.what() << std::endl;
    }
  }
  assert(!testObjCounter.getRefCount());
  testObjCounter.finalize();
  
  std::cout << '\n' << s1ptr->length() << '\n' << *s1ptr;
  delete s1ptr;
  s1ptr = nullptr;
  
  return 0;
}

Когда возникает необходимость изменить контейнер, поток записи (безо всякой блокировки) делает необходимые изменения в экземпляре №2,
 после чего делает его копию (№3), в системе при этом всё ещё хранится копия #1, которая в данный момент используется ТОЛЬКО для ЧТЕНИЯ.

После всего этого каким-то образом необходимо сделать так, чтобы, при новом обращении к структуре выше, потоки ЧТЕНИЯ получали доступ
 к уже новой копии #3 (а не к устаревшей копии №1), с обнулённым, разумеется, счётчиком доступа к копии #3, а старые потоки,
  завершив работу со старой копией #1 (обнулив её счётчик), удалили устаревшую копию #1.
Таки образом, де-факто, старая копия 1 заменяется новой копией 3. Всегда актуальная копия 2 остаётся дальше ждать новой порции изменений.
(Описанный в этом абзаце механизм не реализован в коде выше, он потребует его усложнения, и, возможно, введения откреплённых потоков,
 ожидающих исчерпания ссылок для удаления устаревших копией вместе со счётчиком этих откреплённых потоков, для реализации spin-locka,
  необходимого при завершении работы приложения - хотя это можно в некоторых случаях опустить:
   тогда система по завершении работы приложения автоматически заберёт себе назад все ресурсы, выделенные приложению)

Warning: the behavior is undefined if the mutex is owned by ANY thread OR
 if ANY thread terminates while holding any ownership of the mutex

Плюсы:

- высокая масштабируемость и производительность:
   блокирование только на короткий период запроса/освобождения доступа и при (потенциально редком) замене копии

- (при большом количестве читающих потоков) дополнительной памяти требуется значительно меньше, чем в случае с копированием при чтении

- значительно меньшая частота операций выделения/освобождения памяти под копии, чем в случае с копированием при чтении
  (меньшая фрагментация памяти)

Минусы:

- медленная блокирующая [на самом деле не совсем: https://en.wikipedia.org/wiki/Non-blocking_algorithm] синхронизация

- стратегия описана ТОЛЬКО для случая c ОДНИМ единственным РЕДКО пишущим потоком (не применима в других случаях)

- весьма сложная и запутанная реализация
  (легко допустить ошибку, приводящую к редко возникающему неочевидному сложновоспроизводимому состоянию гонки)

- требует дополнительной памяти для хранения копий контейнера; постоянное выделение/освобождение памяти порождает фрагментацию
  (т. к. количество хранимых копий ограниченно, можно попытаться организовать их хранение в один раз заранее выделенной памяти)

- не применимо, если читающие потоки ВСЕГДА должны видеть актуальное состояние контейнера

Примечание:

По-сути, речь идёт о реализации некой многоверсионной системы синхронизации.
В принципе, можно подумать и о других способах реализации синхронизации на основе версий.
Минус подобных систем - необходимость введения предела релевантности: необходим сложный механизм замены читаемой копии на релевантную
 при устаревании.
Замена осуществляется либо мягким путём: при полном освобождении объекта - число ссылающихся на него равно нулю (счётчик атомарный),
ЛИБО жёстким путём при превышении предела устаревания копии.

Кстати, вот: http://preshing.com/20160726/using-quiescent-states-to-reclaim-memory

Идея заключается в том, чтобы в одном глобальном объекте, который и управляет версиями, хранить, скажем, таблицу (хэш карту) соответствия
 версиям (номер версии - uint64) ID потоков, которые их используют (можно просто хранить таблицу счётчиков ссылок по версиям).
Если количество активных ссылок на версию равно 0 и при этом эта версия - не последняя (проверять лучше по адресу объектов версий)
 - то при последнем релизе (когда счётчик опускается с 1 до 0) - удалять эту версию из памяти и из таблицы.

Так же, для удаления старых копий можно использовать введённый в C++11 механизм поддержки сборки мусора:
 http://en.cppreference.com/w/cpp/memory/gc/undeclare_reachable

--------------------------------------------------------------------------------------------------------------------------------------

4) Использовать Readers–writer (shared-exclusive | multiple readers/single-writer | multi-reader) lock

Allows concurrent access for read-only operations, while write operations require exclusive access.
Multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data.
When a writer is writing the data, ALL other writers OR readers will be blocked until the writer is finished writing.
A common use might be to control access to a data structure in memory that cannot be updated atomically and is invalid
 (and should NOT be read by another thread) until the update is complete.
Readers–writer locks are usually constructed on top of mutexes and condition variables, OR on top of semaphores.

Плюсы:

- готовая реализация:

Unix: POSIX 'pthread_rwlock_t'

Windows: Vista+ 'SRWLock'

Cross-platform:
C++14 'std::shared_mutex'
Boost 'boost::shared_mutex', 'boost::upgrade_mutex'

- имеет определённую гибкость: can be designed with different priority policies for reader vs. writer access -
   to always give priority to readers (read-preferring), to always give priority to writers (write-preferring)
    OR be unspecified with regards to priority

Минусы:

- только для ситуации много читающих, мало пищущих

- блокирующая синхронизация

--------------------------------------------------------------------------------------------------------------------------------------

Стратегия Б: синхронизация отдельных элементов контейнера

Общие плюсы:

- высокая масштабируемость: нет необходимости блокировать доступ ко всему контейнеру даже на малое время

- удобно, если потоки чтения ВСЕГДА работают не со всем контейнером, а лишь с ограниченным количеством его отдельных элементов
  (особенно если работа с отдельными элементами контейнера равномерно распределена между потоками, минимизируя таким образом коллизии)

- если класс элемента контейнера УЖЕ реализован потокобезопасно - делать ВООБЩЕ ничего не надо

Общие минусы:

- данная стратегия применима ТОЛЬКО в тех случаях, когда поток(и) изменения меняют ТОЛЬКО отдельные элементы контейнера,
   НЕ меняя при этом сам контейнер (в частности, размер и адреса выделенной под контейнер памяти, инвалидируя ссылки и указатели)
    неприменимо, если читающие потоки работают именно с контейнером в целом (например, могут менять количество и порядок элементов)
     [хотя при определённых условиях можно допустить и изменение порядка]

- последовательное изменение пишущим потоком N атомарных в отдельности элементов в совокупности НЕ является атомарным
  (изменение каждого отдельно взятого элемента индивидуально атомарно, НО последовательность таких изменений НЕ является атомарной
   и для достижения транзакционной семантики требует отдельной блокирующей синхронизации)

-------------------------------------------------------------------------------------------------------------------------------------- 

0) Эксклюзивная синхронизация доступа к элементу контейнера

Плюсы:

- отсутствие необходимости выделять много дополнительной памяти под копии (а так же удалять их потом, порождая фрагментацию)

- простая и очевидная реализация: достаточно одного примитива синхронизации

- хороший вариант для обратного случая: много записей, мало чтения

Минусы:

- (для сложных классов с большим количеством методов)
   потенциальная сложность реализации синхронизации для хранимого типа данных - чем сложнее объект хранения,
    чем больше у него методов чтения/изменения, тем больше точек синхронизации и тем выше шанс возникновения ошибки синхронизации
    (сложность так же возникает, если нужно иметь один и тот же тип и потокобезопасным для использования в конкурентной седе и
     не потокобезопасным для увеличения производительности - придётся либо делать класс шаблонным, либо, что куда хуже,
      использовать препроцессор, либо оборачивать класс в синхронизированную обёртку)

- для "чужих" объектов (объектов, чей код не может быть модифицирован), если объекты не являются потокобезопасными по-умолчанию,
   потребуется писать класс - обёртку (либо свой синхронизированный аналог)

- плохая масштабируемость в системе с большим количеством потоков, часто читающих сходные элементы

- низкопроизводительная блокирующая синхронизация

- не лучший вариант для элементов со структурой, позволяющей оптимизировать конкурентный доступ
   посредством единовременного эксклюзивного блокирования лишь части данных элемента, а не всего элемента целиком

--------------------------------------------------------------------------------------------------------------------------------------

1) Копирование элементов контейнера при чтении

Каждый ЧИТАЮЩИЙ поток делает себе копии ОТДЕЛЬНЫХ нужных ему элементов контейнера и затем уже работает с ними.

ПЛЮСЫ и МИНУСЫ в целом такие же как в ситуации с [копированием контейнера при чтении], НО копирование отдельных элементов,
 вместо всего контейнера, быстрее (короче окно блокирования) и требует меньше памяти (проще оптимизировать с выделением памяти заранее)

--------------------------------------------------------------------------------------------------------------------------------------

2) Использование атомарных элементов контейнера

КАЖДЫЙ объект контейнера - атомарный объект.
В целом способ похож на [эксклюзивную синхронизацию доступа к элементу контейнера], НО есть важные нюансы, поэтому вынесен отдельно.

Плюсы:

- ОЧЕНЬ простая реализация: достаточно обернуть каждый объект в std::atomic<T>

- (ТОЛЬКО для стандартных встроенных целых арифметических типов, умещающихся в регистр ЦП [int, bool])
   быстрая (примерно как промах по кэшу) неблокирующая синхронизация

Минусы:

- ТОЛЬКО для тривиально копируемых (TriviallyCopyable) типов

--------------------------------------------------------------------------------------------------------------------------------------

3) Синхронизация отдельных полей внутри элемента контейнера

Применимо в том случае, когда элементом контейнера выступает простая аггрегирующая структура.
Сама структура не содержит каких-либо примитивов синхронизации, НО КАЖДОЕ её поле атомарно.

ПЛЮСЫ и МИНУСЫ в целом те же, что характерны для стратегии [Б] в целом, с той лишь разницей, что мы ещё сильнее понижаем
 уровень атомарности, перенося его с отдельного элемента контейнера до отдельного поля элемента контейнера (с соотв. последствиями)

Серьёзным минусом является то, что данный способ мало применим, т. к. сложно себе представить ситуацию, когда объект состоит из
 несвязаных между собой частей, которые можно менять по отдельности друг от друга.

--------------------------------------------------------------------------------------------------------------------------------------

Примечание: критическая секция в терминологии WinAPI
 (там есть критическая секции и мьютекс: http://preshing.com/20111124/always-use-a-lightweight-mutex/),
  в терминологии STL/boost - это мюьтекс
  (reentrant или нет, в WinAPI критическая секция поддерживает рекурсию,
   в STL обычный мьютекс не обязан поддерживать рекурсивный вход по-стандарту)
