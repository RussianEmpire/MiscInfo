Задача:

Есть некоторый объект (например, контейнер STL), который в конкурентной среде (несколькими потоками) изменяется и читается.
Соотношение операций чтение / запись: 95/5 (на одну операцию записи приходится 19 операций чтения).
Приведите несколько способов организации доступа к данным объекта, опишите плюсы и минусы каждого способа.
______________________________________________________________________________________________________________________________________

Решение:

Задача сформулирована слишком широко, что порождает множество возможных вариантов её решения.
Рассмотрим примеры решений в случае с некоторым абстрактным контейнером.

--------------------------------------------------------------------------------------------------------------------------------------

Стратегия А: синхронизация контейнера целиком

--------------------------------------------------------------------------------------------------------------------------------------

0) Взять изначально готовую потокобезопасную (ИЗНУТРИ) реализацию контейнера

Плюсы:

- решение из коробки: не нужно писать никакого дополнительного кода (быстро, просто)

Минусы:

- её надо где-то взять, т. е. придётся связываться с какой-то третьесторонней библиотекой, нет гарантий, что там нет ошибок
   (если ошибки будут найдены, не ясно что с ними делать: исправлять самому и делать пулл реквест или искать другую реализацию)

- (скорее всего) не гибкое, не масштабируемое решение: разработчик контейнера не может заранее знать,
   в каких условиях будет использоваться контейнер,
    т. е. код скорее всего будет жёстко синхронизирован в лоб, без простора для оптимизаций
     (избежания лишних блокировок там, где они ситуационно не нужны)

- (скорее всего) низкопроизводительная блокирующая синхронизация

- хотя сам по себе контейнер синхронизирован, не очень понятно, как при этом обстоит дело с синхронизацией ХРАНИМЫХ контейнером объектов
   (контейнер возвращает нам их копии при обращении или объекты уже каким-то образом синхронизированы?)

--------------------------------------------------------------------------------------------------------------------------------------

1) Синхронизация доступа ко всему контейнера ИЗВНЕ контейнера

Сам контейнер реализован НЕ потокобезопасно, а синхронизацию ВСЕХ операций чтения и записи берёт на себя непосредственно тот код,
 который и осуществляет чтение/запись (либо контейнер оборачивается в примитивную синхронизированную обёртку).
За контейнером закрепляется ОДНА единственная критическая секция, которая блокирует ЛЮБОЙ параллельный доступ к контейнеру.
Т. е. доступ к контейнеру ВСЕГДА эксклюзивный: один поток пишет или читает, остальные ждут.

Плюсы:

- простота реализации: всего один примитив синхронизации, минимум точек синхронизации и, как следствие,
   минимум потенциальных, сложно локализуемых, сложно воспроизводимых ошибок синхронизации

- отсутствие необходимости выделять много дополнительную память

- хороший вариант для обратного случая: много записей, мало чтения
   (имеется ввиду когда изменять нужно САМ контейнер, причём эксклюзивно, а не по частям - например, вектор)

Минусы:

- ОЧЕНЬ плохая масштабируемость в системе с большим количеством потоков в своей абсолютной массе работающих на чтение
   (т. е. решение ТОЧНО не для указанного случая, как максимум временно-костыльный вариант
    или вариант для нетребовательных ко времени отклика систем)

- низкопроизводительная (блокировка по цене примерно как переключение контекста) блокирующая синхронизация
   (к слову, в WinAPI критическая секция оптимизирована для случаев отсутствия РЕАЛЬНОЙ конкуренции - выход из критической секции дешевле,
    если за время блокировки конкурентные потоки в неё НЕ входили)

- не лучший вариант для контейнеров с распределённой структурой хранения (хэш-карты, дэки),
   которые позволяют выстраивать более гибкие и масштабируемые стратегии синхронизации, единовременно блокирующие
    лишь часть контейнера, а не весь

--------------------------------------------------------------------------------------------------------------------------------------

2) Копирование контейнера при чтении

Способ синхронизации во многом аналогичен п. 1, НО
 КАЖДЫЙ читающий поток эксклюзивно блокирует контейнер ТОЛЬКО на время создания его ПОЛНОЙ копии.
Далее поток работает уже со своей индивидуальной копией.

Плюсы:

- простота реализации: всего один примитив синхронизации, минимум точек синхронизации и т. д.

- (в определённых случаях) эффективность по времени: работающий со своей индивидуальной копией поток НИКАК не мешает массе других потоков
   (в нашем случае, в первую очередь, читающих)

- удобно в том случае, когда много читающих потоков достаточно БЫСТРО делают копии и потом долго с этими своими индивидуальными копиями работают,
   таким образом, редко обращаясь за релевантным состоянием исходного объекта и не препятствуя его свободному изменению в это время

Минусы:

- не применимо, если читающие потоки ВСЕГДА должны видеть актуальное состояние контейнера
   (оно может изменится за время работы с копией, которая, таким образом, утрачивает релевантность)

- не имеет смысла в тех случаях, когда статистически среднее время чтения контейнера потоком меньше или сопоставимо
   со средним временем копирования этого контейнера (пустая трата времени и памяти на копирование, лишняя фрагментация памяти)

- требует дополнительной памяти, особенно критично:
   а) для систем с сильно ограниченным общим объмом памяти
   б) в случае большого размера контейнера и/или большого количества потоков чтения
   в) для кода собранного с низкой разрядностью указателя, не способного адресовать большие объёмы виртуальной памяти
       (пример: ОС Win32, приложение с 32-ух битными указатели, не поддерживающими большие адреса [LargeAddressAware],
        в системе с установленным дефолтным ограничением 2 Гб/процесс)

--------------------------------------------------------------------------------------------------------------------------------------
// ---
3) Копирование контейнера при записи

В системе хранится одновременно две копии объекта:
 1) эксклюзивно синхронизированная на чтение и на запись ВСЕГДА релевантная
 2) полностью НЕ синхронизированная, предназначенная ИСКЛЮЧИТЕЛЬНО только для чтения





Плюсы:

- минимум дополнительной памяти

- предел релевантности: необходим сложный механизм замены читаемой копии на релевантную при устаревании
   (замена осуществляется либо мягким путём: при полном освобождении объекта - число ссылающихся на него равно нулю, счётчик атомарный
    ЛИБО жёстким путём при превышении предела устаревания копии)

Минусы:

- 


Стратегия Б: синхронизация отдельных элементов контейнера

0) Копирование элементов контейнера при чтении



Плюсы:

- удобно, если потоки чтения ВСЕГДА работают не со всем контейнером, а лишь с весьма ограниченным количеством его отдельных элементов
   (особенно если работа с отдельными элементами контейнера равномерно распределена между потоками, минимизируя таким образом коллизии)

Минусы:

- неприменимо, если читающие потоки работают именно с контейнером в целом (например, могут менять количество и порядок элементов)

- потенциальная сложность реализации синхронизации для хранимого типа данных - чем сложнее объект хранения, чем больше у него методов чтения/изменения,
   тем больше точек синхронизации и тем выше шанс возникновения ошибки синхронизации
    (сложность так же возникает, если нужно иметь один и тот же тип и потокобезопасным для использования в конкурентной седе и не потокобезопасным для увеличения производительности -
     придётся либо делать класс шаблонным, либо, что куда хуже, использовать препроцессор, либо оборачивать класс в синхронизированную обёртку )

- для "чужих" объектов (объектов, чей код не может быть модифицирован), если объекты не являются потокобезопасными по-умолчанию, потребуется писать класс - обёртку
   (либо свой синхронизированный аналог)












хэш контейнеры, дэки в этом плане более гибки, так как имеют распределённую структуру хранения


неблокирующая синхронизация путём атомарного поля времени

неблокирующая синхронизация атомарных объектов внутри контейнера

КАЖДЫЙ объект контейнера - атомарный объект, атомарность которого достигается путём быстрой неблокирующей синхронизации.

Плюсы:

- ОЧЕНЬ простая реализация (достаточно обернуть каждый объект в std::atomic<T>)


Минусы:

- применимо ТОЛЬКО для тривиальных встроенных типов (кроме типов с плавющей запяттой), умещающихся в регистр ЦП (int, bool)

- ТОЛЬКО для случая, когда изменяющий поток меняет лишь ОТДЕЛЬНЫЕ элементы контейнера, но НЕ САМ контейнер

- изменение N атомарных элементов в совокупности НЕ является атомарным
   (изменение каждого отдельно взятого элемента индивидуально атомарно, НО последовательность таких изменений НЕ является атомарной
    и для достижения транзакционной семантики требует отдельной блокирующей синхронизации)




неблокирующая синхронизация атомарных полей внутри объекта контейнера

Плюсы:

- ОЧЕНЬ простая реализация (достаточно обернуть каждое поле объекта в std::atomic<T>)

Минусы:

- применимо ТОЛЬКО для полей тривиального типа (см. выше)

- изменение группы полей объекта атомарно по отдельности, но не атомарно в целом
   (изменение объекта гарантировано атомарно только если каждый раз меняется не более ОДНОГО поля)



Примечание: критическая секция в терминологии WinAPI (там есть критическая секции и мьютекс), в терминологии STL/boost - это мюьтекс
 (reentrant или нет, в WinAPI критическая секция поддерживает рекурсию,
  в STL обычный мьютекс не обязан поддерживать рекурсивный вход по-стандарту)






see also

https://en.wikipedia.org/wiki/Readers–writer_lock
